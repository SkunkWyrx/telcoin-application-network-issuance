import fs from "fs";
import { Address } from "viem";
import { ChainId } from "../config";
import { DeepReadonly, ensureDataDirectory, ensureDataFile } from "../helpers";

/**
 * @dev This enum is used to differentiate users based on their referral status
 * @param Referrer A user who has referred at least one Referee via referral code
 * @param Referee To be eligible for TAN issuance, users must be referred by another user, ie `Referee`
 * @param Staker To be eligible for rewards, Referees must post a nonzero TEL stake
 * @todo This enum should be reevaluated because members are related to granularity
 * and not mutually exclusive
 */
export enum UserType {
  Staker,
  Referee,
  Referrer,
}

export interface User {
  user_id: string;
  type: UserType;
  addresses: Partial<{ [chain in ChainId]: Address }>;
  referral_code: string;
  referred_by_user_id: string | undefined;
  referred_user_ids: (string | undefined)[];
}

/**
 * This class fetches and keeps track of users.
 */
export abstract class BaseUserRegistry {
  private _initialized = false;

  private _users: User[] = [];
  private _usersById: Map<string, User> = new Map();
  private _usersByAddressAndChain: Map<ChainId, Map<Address, User>> = new Map();

  get initialized() {
    return this._initialized;
  }

  get users(): DeepReadonly<User[]> {
    this.whenInitialized();
    return this._users;
  }

  private whenInitialized() {
    if (!this._initialized) {
      throw new Error("Not Initialized");
    }
  }

  /**
   * Initialize the user registry
   */
  async init() {
    if (this._initialized) {
      return;
    }

    this._users = await this.fetchUsers();

    for (const user of this._users) {
      this._usersById.set(user.user_id, user);

      const chains = Object.keys(user.addresses).map(parseInt) as ChainId[];

      // set in usersByAddressAndChain
      for (const chain of chains) {
        const address = user.addresses[chain]!;
        let usersByAddress = this._usersByAddressAndChain.get(chain);
        if (!usersByAddress) {
          usersByAddress = new Map();
          this._usersByAddressAndChain.set(chain, usersByAddress);
        }
        usersByAddress.set(address, user);
      }
    }

    this._initialized = true;
  }

  /**
   * @param id User ID
   * @returns The user with the given ID, or undefined if no user exists with the given ID
   */
  getUserById(id: string): DeepReadonly<User> | undefined {
    this.whenInitialized();
    return this._users.find((user) => user.user_id === id);
  }

  /**
   * @param address Address of the user to get
   * @param chain Chain of the address
   * @returns The user with the given address on the given chain, or undefined if no user exists with the given address and chain
   */
  getUserByAddressAndChain(
    address: Address,
    chain: ChainId
  ): DeepReadonly<User> | undefined {
    this.whenInitialized();
    const usersByAddress = this._usersByAddressAndChain.get(chain);
    if (usersByAddress) {
      return usersByAddress.get(address);
    }
  }

  /**
   * @param address Address of the user to get
   * @returns The user with the given address on any chain, or undefined if no user exists with the given address
   */
  getUserByAddress(address: Address): DeepReadonly<User> | undefined {
    this.whenInitialized();
    for (const [chain, map] of this._usersByAddressAndChain) {
      const user = this.getUserByAddressAndChain(address, chain);
      if (user) {
        return user;
      }
    }
  }

  /**
   * @returns All users
   */
  abstract fetchUsers(): Promise<User[]>;
}

/** LocalFileUserRegistry
 * This class fetches and stores users from a local TAN-generated file
 */
import UserEntry from "../data/UserEntry";
import path from "path";

export class LocalFileUserRegistry extends BaseUserRegistry {
  async fetchUsers(): Promise<User[]> {
    let userEntriesData = getUserEntries();
    let users: User[] = [];
    try {
      // `userEntries` should be imported as an array generated by TAN backend
      const userEntries = userEntriesData as UserEntry[];
      users = userEntries.map((entry: UserEntry) => {
        // parse the entries from JSON string to array
        const referredUserIds = JSON.parse(entry.referred_user_ids) as (
          | string
          | null
        )[];

        // TAN backend uses single `null` member for empty `referred_user_ids`
        const filteredReferredUserIds = referredUserIds.filter(
          (id) => id !== null
        );
        // after filtering null referee ids, determine this user type
        const userType =
          filteredReferredUserIds.length > 0
            ? UserType.Referrer
            : UserType.Staker;

        // construct User object from JSON entry
        const user: User = {
          user_id: entry.user_id,
          type: userType,
          addresses: {
            [ChainId.Polygon]: entry.polygon_wallet_address as Address,
          },
          referral_code: entry.referral_code,
          referred_by_user_id: entry.referred_by_user_id,
          referred_user_ids: referredUserIds.map((refereeId) =>
            refereeId ? refereeId : undefined
          ),
        };

        return user;
      });
    } catch (err) {
      console.error(err);
      throw new Error("Malformed users_wallets_referrals.json input");
    }
    return Promise.resolve(users);
  }
}

/**
 * Gets user data from the JSON file, creating it if it doesn't exist
 */
export function getUserEntries(): UserEntry[] {
  const DATA_DIRECTORY = path.join(__dirname, "data");
  const DATA_FILE_PATH = path.join(
    __dirname,
    "../data",
    "users_wallets_referrals.json"
  );
  const DEFAULT_USER_DATA: UserEntry[] = [];

  try {
    ensureDataDirectory(DATA_DIRECTORY);
    ensureDataFile(DATA_FILE_PATH, DEFAULT_USER_DATA);

    const fileContent = fs.readFileSync(DATA_FILE_PATH, "utf-8");
    return JSON.parse(fileContent) as UserEntry[];
  } catch (error) {
    console.warn(
      "Error reading user data, falling back to empty array:",
      error
    );
    return DEFAULT_USER_DATA;
  }
}
